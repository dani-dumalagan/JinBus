# -*- coding: utf-8 -*-
"""SineWave.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19z3a-zJ5gbYnWpXLaqyxxgF3EP4xqqm9
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense

import numpy as np
import os
import sys

import matplotlib.pyplot as plt
import pandas as pd
import math


SAMPLE = 1000
SEED = 1337

np.random.seed(SEED)
tf.random.set_seed(SEED)

# data preparation
x_values = np.random.uniform(low=0, high=2*math.pi, size=SAMPLE)
np.random.shuffle(x_values)
y_values = np.sin(x_values)
y_noise = np.sin(x_values)

y_noise += 0.1*np.random.randn(len(y_noise))

TRAIN_SPLIT = int(0.6 *SAMPLE)
TEST_SPLIT = int(0.2*SAMPLE + TRAIN_SPLIT)

x_train, x_validate, x_test = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])
y_train, y_validate, y_test = np.split(y_noise, [TRAIN_SPLIT, TEST_SPLIT])

y_clean = y_values[TEST_SPLIT:]

print('{}'.format(x_train.shape))

# Build model
model = tf.keras.Sequential()
model.add(Dense(20, activation='relu', input_shape=(1,)))
model.add(Dense(20, activation='relu'))
model.add(Dense(1))

model.compile(optimizer='rmsprop', loss='mse', metrics=['mae'])
model.summary()

# Train the model
metricInfo = model.fit(x_train, y_train, epochs=600, validation_data=(x_validate, y_validate), verbose = False)

predictions = model.predict(x_test)
plt.clf()
plt.plot(x_test, y_clean, 'b.', label='Observation')
plt.plot(x_test, predictions, 'r*', label='Predictions')
plt.legend()
plt.show()

model.save('baseModel.h5')


# To convert model to lightweight version

converter = tf.lite.TFLiteConverter.from_keras_model(model)
converter.optimization= [tf.lite.Optimize.DEFAULT]
quantModel = converter.convert()
with open('liteModel.tflite', 'wb') as f:
  f.write(quantModel)


def get_zipped_model_size(modeFile):
    import os
    import zipfile
    import tempfile

    _, zipped_file = tempfile.mkstemp('.zip')
    with zipfile.ZipFile(zipped_file, 'w', compression=zipfile.ZIP_DEFLATED) as f:
        f.write(modeFile)

    return os.path.getsize(zipped_file)


baseSize = get_zipped_model_size('baseModel.h5')
liteSize = get_zipped_model_size('liteModel.tflite')
print('Size of Base Model: {}'.format(baseSize))
print('Size of Lite Model: {}'.format(liteSize))

def testPostQuantModel(x_test, y_noise, fileModel):
  interpreter = tf.lite.Interpreter(model_path=fileModel)
  interpreter.allocate_tensors()

  input_index = interpreter.get_input_details()[0]["index"]
  output_index = interpreter.get_output_details()[0]["index"]

  pred = []
  for val in x_test:
    x_value_tensor = tf.convert_to_tensor([[val]], dtype=np.float32)
    interpreter.set_tensor(input_index, x_value_tensor)
    interpreter.invoke()

    output = interpreter.get_tensor(output_index)[0]
    pred.append(output)

  pred = np.array(pred)
  plt.clf()
  plt.plot(x_test, y_clean, 'b.', label='Observation')
  plt.plot(x_test, pred, 'r*', label='Predictions')
  plt.legend()
  plt.show()

testPostQuantModel(x_test, y_noise, 'liteModel.tflite')



